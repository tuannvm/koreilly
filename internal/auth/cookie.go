package auth

import (
	"bufio"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/tuannvm/goreilly/internal/config"
)

// -----------------------------------------------------------------------------
// Netscape cookie-file helpers
//
// Many browser extensions (e.g. “EditThisCookie”), curl’s --cookie-jar flag, and
// numerous CLI tools export cookies in the historical “Netscape HTTP Cookie
// File” format.  Each cookie is stored on a single tab-delimited line:
//
//   <domain>  <include_subdomains>  <path>  <secure>  <expires>  <name>  <value>
//
// Example:
//
//   .oreilly.com	TRUE	/	FALSE	2147483647	orm-jwt	eyJhbGciOi…
// -----------------------------------------------------------------------------

// parseNetscapeLine converts a single line of the Netscape cookie format into a
// *http.Cookie.  It returns (nil, nil) for comment/blank lines so callers can
// simply skip when cookie == nil.
func parseNetscapeLine(line string) (*http.Cookie, error) {
	line = strings.TrimSpace(line)
	if line == "" || strings.HasPrefix(line, "#") {
		return nil, nil
	}

	parts := strings.Split(line, "\t")
	if len(parts) != 7 {
		return nil, fmt.Errorf("netscape cookie line should have 7 fields, got %d", len(parts))
	}

	domain := parts[0]
	path := parts[2]
	secure := strings.EqualFold(parts[3], "TRUE")

	// Expires
	var expires time.Time
	if unix, err := strconv.ParseInt(parts[4], 10, 64); err == nil {
		expires = time.Unix(unix, 0)
	} else {
		// Fallback to RFC1123 (some tools emit textual time)
		if t, err2 := time.Parse(time.RFC1123, parts[4]); err2 == nil {
			expires = t
		}
	}

	return &http.Cookie{
		Domain:   domain,
		Path:     path,
		Secure:   secure,
		Expires:  expires,
		Name:     parts[5],
		Value:    parts[6],
		HttpOnly: false, // Netscape format doesn’t carry this flag
	}, nil
}

// LoadCookieFile reads a Netscape-format cookie file and returns all cookies
// whose Domain suffix matches "oreilly.com".
func LoadCookieFile(path string) ([]*http.Cookie, error) {
	// First, read the entire file – we may need to inspect its format
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var cookies []*http.Cookie
	trimmed := strings.TrimSpace(string(data))

	// ---------------------------------------------------------------------
	// 1. Try JSON array format (e.g. Chrome “Export as JSON”)
	// ---------------------------------------------------------------------
	if strings.HasPrefix(trimmed, "[") {
		var jc []struct {
			Name    string `json:"name"`
			Value   string `json:"value"`
			Domain  string `json:"domain"`
			Path    string `json:"path"`
			Secure  bool   `json:"secure"`
			Expires int64  `json:"expires"` // seconds since epoch
		}
		if err := json.Unmarshal(data, &jc); err == nil {
			for _, c := range jc {
				if !strings.HasSuffix(c.Domain, "oreilly.com") {
					continue
				}
				cookies = append(cookies, &http.Cookie{
					Name:    c.Name,
					Value:   c.Value,
					Domain:  c.Domain,
					Path:    c.Path,
					Secure:  c.Secure,
					Expires: time.Unix(c.Expires, 0),
				})
			}
			return cookies, nil
		}
		// If JSON parsing fails, fall through to Netscape parser
	}

	// ---------------------------------------------------------------------
	// 2. Fallback to Netscape-format parsing (original behaviour)
	// ---------------------------------------------------------------------
	scanner := bufio.NewScanner(strings.NewReader(trimmed))
	for scanner.Scan() {
		c, err := parseNetscapeLine(scanner.Text())
		if err != nil {
			continue // skip malformed lines
		}
		if c == nil {
			continue // comment/blank
		}
		if strings.HasSuffix(c.Domain, "oreilly.com") {
			cookies = append(cookies, c)
		}
	}
	if err := scanner.Err(); err != nil {
		return nil, err
	}

	if len(cookies) == 0 {
		return nil, fmt.Errorf("no oreilly.com cookies found in %s", path)
	}
	return cookies, nil
}

// SaveCookies writes the provided cookies to a Netscape-format file under
// ~/.config/goreilly/oreilly_cookies.txt and returns the path.
func SaveCookies(cfg *config.Config, cookies []*http.Cookie) (string, error) {
	configDir, err := os.UserConfigDir()
	if err != nil {
		return "", err
	}
	appDir := filepath.Join(configDir, "goreilly")
	if err := os.MkdirAll(appDir, 0o755); err != nil {
		return "", err
	}

	outPath := filepath.Join(appDir, "oreilly_cookies.txt")
	file, err := os.Create(outPath)
	if err != nil {
		return "", err
	}
	defer file.Close()

	// Header comment to help users recognise the file.
	fmt.Fprintln(file, "# Netscape HTTP Cookie File")
	fmt.Fprintln(file, "# This file was generated by GOReily.")
	for _, c := range cookies {
		// Domain
		domain := c.Domain
		// Include subdomains: treat leading dot as TRUE
		includeSub := "FALSE"
		if strings.HasPrefix(domain, ".") {
			includeSub = "TRUE"
		}
		// Secure flag
		secure := "FALSE"
		if c.Secure {
			secure = "TRUE"
		}
		// Expiry in seconds since Epoch (0 = session cookie)
		expiry := c.Expires.Unix()
		if c.Expires.IsZero() {
			expiry = 0
		}

		fmt.Fprintf(file, "%s\t%s\t%s\t%s\t%d\t%s\t%s\n",
			domain,
			includeSub,
			c.Path,
			secure,
			expiry,
			c.Name,
			c.Value,
		)
	}

	return outPath, nil
}
